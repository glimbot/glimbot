//! Contains logic relating to calculating and tracking spam pressure.

use crate::dispatch::config::{FromStrWithCtx, VerifiedChannel, VerifiedRole, VerifiedUser};
use crate::module::{ModInfo, Module, Sensitivity, CHECKMARK_IN_GREEN_BOX};
use noisy_float::prelude::Float;
use noisy_float::types::R64;
use serenity::client::Context;
use serenity::model::channel::Message;

use std::{fmt, time};

use crate::db::cache::{Cache, TimedCache};
use crate::dispatch::config;
use crate::dispatch::message_info::MsgInfo;
use crate::dispatch::Dispatch;
use crate::error::{GuildNotInCache, LogErrorExt};
use crate::module::moderation::{ActionKind, ModAction};
use crate::module::privilege::PRIV_ROLE;
use crate::util::clock::CacheInstant;
use crate::util::constraints::ConstrainedU64;
use crate::util::ClapExt;

use chrono::Utc;

use futures::StreamExt;
use num::{ToPrimitive, Zero};
use once_cell::sync::Lazy;
use regex::Regex;
use serenity::model::id::{GuildId, UserId};

use serenity::model::prelude::ReactionType::Unicode;

use std::fmt::Formatter;
use std::str::FromStr;
use std::time::Duration;

/// Base pressure generated by sending a message.
pub const DEFAULT_BASE_PRESSURE: f64 = 10.0;
/// Default pressure at which a user will be silenced.
pub const DEFAULT_MAX_PRESSURE: f64 = 60.0;
/// Default pressure for images.
pub const DEFAULT_IMAGE_PRESSURE: f64 = (DEFAULT_MAX_PRESSURE - DEFAULT_BASE_PRESSURE) / 6.0;
/// Default pressure for message length, per UTF-8 codepoint
pub const DEFAULT_LENGTH_PRESSURE: f64 = (DEFAULT_MAX_PRESSURE - DEFAULT_BASE_PRESSURE) / 8000.0;
/// Default pressure per line.
pub const DEFAULT_LINE_PRESSURE: f64 = (DEFAULT_MAX_PRESSURE - DEFAULT_BASE_PRESSURE) / 70.0;
/// Default pressure per ping.
pub const DEFAULT_PING_PRESSURE: f64 = (DEFAULT_MAX_PRESSURE - DEFAULT_BASE_PRESSURE) / 20.0;
/// Default pressure decay; this is the period in seconds for removal of one base pressure.
pub const DEFAULT_PRESSURE_DECAY: f64 = 2.5;
/// Default silence timeout; this the duration of any automutes Glimbot performs.
pub const DEFAULT_SILENCE_TIMEOUT: time::Duration = time::Duration::from_secs(10 * 60);

/// The config key for grabbing a [`SpamConfig`].
pub const SPAM_CONFIG_KEY: &str = "spam_config";
/// The config key for grabbing a role that should be immune to spam checks.
/// Guild owners and moderators cannot generate pressure.
pub const SPAM_IGNORE_ROLE: &str = "spam_ignore_role";

/// Matches known vertical whitespace characters; we count each of them as a "line" separator.
pub static VERTICAL_WHITESPACE_RE: Lazy<Regex> =
    Lazy::new(|| Regex::new(r#"[\r\v\f\n\u2028\u2029]"#).expect("Invalid vertical whitespace RE"));

/// The numerical configuration values for the spam module.
#[derive(Serialize, Deserialize, Copy, Clone)]
pub struct SpamConfig {
    /// Base pressure generated by sending a message.
    pub base_pressure: R64,
    /// Pressure generated by each image in a message.
    pub image_pressure: R64,
    /// Pressure generated per UTF-8 code point in a message.
    pub length_pressure: R64,
    /// Pressure generated per newline in a message.
    pub line_pressure: R64,
    /// The pressure at which a user will be silenced.
    pub max_pressure: R64,
    /// Pressure generated per ping in a message.
    pub ping_pressure: R64,
    /// The amount of time it will take for one `base_pressure` worth of pressure to decay.
    pub pressure_decay: R64,
    /// The amount of time users will be muted for.
    #[serde(with = "humantime_serde")]
    pub silence_timeout: time::Duration,
}

impl FromStr for SpamConfig {
    type Err = serde_json::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        serde_json::from_str(s)
    }
}

impl fmt::Display for SpamConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let s = serde_json::to_string_pretty(self).unwrap_or_else(|_| "{}".to_string());
        write!(f, "{}", s)
    }
}

#[derive(Copy, Clone, Debug, Serialize, Deserialize)]
pub struct UserPressure {
    last_update: CacheInstant,
    pressure: R64,
}

impl Default for UserPressure {
    fn default() -> Self {
        Self {
            last_update: CacheInstant::now(),
            pressure: R64::zero(),
        }
    }
}

impl UserPressure {
    pub fn update(mut self, new_pressure: R64, conf: &SpamConfig) -> UserPressure {
        // First apply the decay.
        if conf.pressure_decay != 0.0 && self.pressure != 0.0 {
            let elapsed = self.last_update.elapsed();
            let decay = R64::try_new(elapsed.as_secs_f64()).unwrap_or_else(R64::zero).raw()
                / conf.pressure_decay.raw().clamp(0.0, f64::MAX);
            let decay = decay * conf.base_pressure.raw();
            let new_pressure = (self.pressure.raw() - decay).clamp(0.0, f64::MAX);
            self.pressure = R64::new(new_pressure);
        }

        self.pressure = R64::new((self.pressure.raw() + new_pressure.raw()).clamp(0.0, f64::MAX));
        self.last_update = CacheInstant::now();
        self
    }

    pub fn with_pressure(new_pressure: R64) -> UserPressure {
        Self {
            pressure: new_pressure,
            ..Default::default()
        }
    }
}

impl Default for SpamConfig {
    fn default() -> Self {
        Self {
            base_pressure: R64::new(DEFAULT_BASE_PRESSURE),
            image_pressure: R64::new(DEFAULT_IMAGE_PRESSURE),
            length_pressure: R64::new(DEFAULT_LENGTH_PRESSURE),
            line_pressure: R64::new(DEFAULT_LINE_PRESSURE),
            max_pressure: R64::new(DEFAULT_MAX_PRESSURE),
            ping_pressure: R64::new(DEFAULT_PING_PRESSURE),
            pressure_decay: R64::new(DEFAULT_PRESSURE_DECAY),
            silence_timeout: DEFAULT_SILENCE_TIMEOUT,
        }
    }
}

/// Calculates the message pressure of a single message.
pub fn message_pressure(conf: &SpamConfig, msg: &Message) -> R64 {
    let mut pres = conf.base_pressure.raw();

    // Add image pressure.
    pres += msg
        .attachments
        .iter()
        .filter_map(|a| a.height.map(|_| conf.image_pressure.raw()))
        .sum::<f64>();

    // Length pressure.
    pres += msg.content.len() as f64 * conf.length_pressure.raw();

    // Pings.
    pres += ((msg.mentions.len() + msg.mention_roles.len()) as f64 + msg.mention_everyone as u64 as f64)
        * conf.ping_pressure.raw();

    // Line pressure.
    pres += VERTICAL_WHITESPACE_RE.find_iter(&msg.content).count() as f64 * conf.line_pressure.raw();

    R64::try_new(pres).unwrap_or_else(R64::max_value)
}

/// Module containing the spam filtering logic for Glimbot.
pub struct SpamModule {
    cache: TimedCache<GuildId, SpamConfig>,
    user_pressure: Cache<GuildId, Cache<UserId, UserPressure>>,
}

impl Default for SpamModule {
    fn default() -> Self {
        Self {
            cache: TimedCache::new(std::time::Duration::from_secs(10)),
            user_pressure: Cache::null(),
        }
    }
}

#[allow(clippy::enum_variant_names)]
#[derive(Debug, structopt::StructOpt)]
enum PressureOp {
    GetFor {
        user: String,
    },
    SetFor {
        user: String,
        #[structopt(parse(try_from_str = crate::util::parse_nonnegative_real))]
        pressure: R64,
    },
    ClearFor {
        user: String,
    },
}

impl PressureOp {
    pub fn user(&self) -> &str {
        match self {
            PressureOp::GetFor { user } => user.as_ref(),
            PressureOp::SetFor { user, .. } => user.as_ref(),
            PressureOp::ClearFor { user } => user.as_ref(),
        }
    }
}

#[derive(Debug, structopt::StructOpt)]
enum SpamOpts {
    Clean {
        #[structopt(default_value = "1")]
        num: ConstrainedU64<1, 100>,
        #[structopt(short, long)]
        channel: Option<String>,
        #[structopt(short, long)]
        who: Option<String>,
    },
    Pressure {
        #[structopt(subcommand)]
        op: PressureOp,
    },
}

#[async_trait::async_trait]
impl Module for SpamModule {
    fn info(&self) -> &ModInfo {
        #[doc(hidden)]
        static INFO: Lazy<ModInfo> = Lazy::new(|| {
            ModInfo::with_name("spam", "allows moderators to see/set user spam pressure, and to clean up messages in a channel or from a user.")
                .with_sensitivity(Sensitivity::High)
                .with_message_hook(true)
                .with_tick_hook(true)
                .with_command(true)
                .with_config_value(config::Value::<VerifiedRole>::new(SPAM_IGNORE_ROLE, "A role which should be ignored for spam pressure calculations. The guild owner and moderators will not generate pressure."))
                .with_config_value(config::Value::<SpamConfig>::with_default(SPAM_CONFIG_KEY, "A JSON object describing various options for calculating spam pressure. See Glimbot's documentation for more info.", Default::default))
        });
        &INFO
    }

    async fn process(
        &self,
        dis: &Dispatch,
        ctx: &Context,
        orig: &Message,
        command: Vec<String>,
    ) -> crate::error::Result<()> {
        let opts = SpamOpts::from_iter_with_help(command)?;

        let before = orig.timestamp;
        let gid = orig.guild_id.unwrap();

        match opts {
            SpamOpts::Clean { num, channel, who } => {
                let channel = futures::stream::iter(channel.as_ref())
                    .then(|c| VerifiedChannel::from_str_with_ctx(&c, ctx, gid))
                    .next()
                    .await
                    .transpose()?
                    .unwrap_or_else(|| VerifiedChannel::from_known(orig.channel_id));

                let who = futures::stream::iter(who.as_ref())
                    .then(|u| VerifiedUser::from_str_with_ctx(&u, ctx, gid))
                    .next()
                    .await
                    .transpose()?
                    .or_else(|| {
                        orig.referenced_message
                            .as_ref()
                            .map(|m| VerifiedUser::from_known(m.author.id))
                    });

                let num_cleaned = clean_messages(dis, ctx, num, before, gid, channel, who).await?;
                orig.reply(ctx, format!("```Cleaned {} message(s)```", num_cleaned))
                    .await?;
            }
            SpamOpts::Pressure { op } => {
                let user = VerifiedUser::from_str_with_ctx(op.user(), ctx, gid).await?;
                match op {
                    PressureOp::GetFor { .. } => {
                        let pres = self
                            .user_pressure
                            .get_or_insert_default(&gid)
                            .get_or_insert_default(&user.into_inner());

                        orig.reply(ctx, format!("`{}`", pres.pressure)).await?;
                    }
                    PressureOp::SetFor { pressure, .. } => {
                        self.user_pressure
                            .get_or_insert_default(&gid)
                            .insert(&user.into_inner(), UserPressure::with_pressure(pressure));
                        orig.react(ctx, CHECKMARK_IN_GREEN_BOX).await?;
                    }
                    PressureOp::ClearFor { .. } => {
                        self.user_pressure
                            .get_or_insert_default(&gid)
                            .insert(&user.into_inner(), UserPressure::default());
                        orig.react(ctx, CHECKMARK_IN_GREEN_BOX).await?;
                    }
                }
            }
        }

        Ok(())
    }

    async fn on_tick(&self, _dis: &Dispatch, _ctx: &Context) -> crate::error::Result<()> {
        Ok(())
    }

    async fn on_message(&self, dis: &Dispatch, ctx: &Context, orig: &Message) -> crate::error::Result<()> {
        let gid = match orig.guild_id {
            None => {
                trace!("saw DM or other non-guild message");
                return Ok(());
            }
            Some(id) => id,
        };

        let start = std::time::Instant::now();
        let f = async {
            let db = dis.db(gid);
            let v = dis.config_value_t::<SpamConfig>(SPAM_CONFIG_KEY).unwrap();
            Ok(*v.get_or_default(&db).await?)
        };
        let conf = self.cache.get_or_insert_with(&gid, f).await?;
        let pre_mess = start.elapsed();
        let lp = message_pressure(&conf, orig);

        let pres_cache = self.user_pressure.get_or_insert_default(&gid);
        let pres = pres_cache
            .update_and_fetch(&orig.author.id, |o| {
                let o = o.cloned().unwrap_or_else(Default::default);
                Some(o.update(lp, &conf))
            })
            .unwrap();

        if pres.pressure > conf.max_pressure {
            let r = mute_for_spam(dis, ctx, conf.as_ref(), orig).await;
            r.log_error();
            if let Ok(true) = r {
                // tell em to shut up
                orig.react(ctx, Unicode("⚠️".to_string()))
                    .await
                    .map_err(crate::error::Error::from)
                    .log_error();
            }
        }

        let finish = start.elapsed();
        trace!(
            "message pressure was {:.3}, took {:?}, {:?} of which was cache",
            lp.raw(),
            finish,
            pre_mess
        );
        trace!("user pressure is {:?}", pres.as_ref());
        Ok(())
    }
}

async fn mute_for_spam(dis: &Dispatch, ctx: &Context, conf: &SpamConfig, orig: &Message) -> crate::error::Result<bool> {
    // Ignore if this is the guild owner.
    let guild = orig.guild(ctx).await.ok_or(GuildNotInCache)?;
    if guild.owner_id == orig.author.id {
        trace!("not muting guild owner");
        return Ok(false);
    }
    let db = dis.db(guild.id);

    let mod_role = dis.config_value_t::<VerifiedRole>(PRIV_ROLE)?.get(&db).await?;

    let mem = orig.member.clone().unwrap();
    if let Some(r) = mod_role {
        let r = *r;
        if mem.roles.contains(&r.into_inner()) {
            trace!("not muting moderator");
            return Ok(false);
        }
    }

    let ignore_role = dis.config_value_t::<VerifiedRole>(SPAM_IGNORE_ROLE)?.get(&db).await?;

    if let Some(r) = ignore_role {
        let r = *r;
        if mem.roles.contains(&r.into_inner()) {
            trace!("not muting ignore role");
            return Ok(false);
        }
    }

    let duration = if conf.silence_timeout > Duration::from_secs(0) {
        Some(conf.silence_timeout.into())
    } else {
        None
    };

    let full_mem = orig.member(ctx).await?;
    let me = dis.bot().await;
    let action = ModAction::new(full_mem, orig.channel_id, me, ActionKind::Mute)
        .with_duration(duration)
        .with_reason("Spam")
        .with_original_message(orig.id);
    action.act(dis, ctx).await?;
    action.report_action(dis, ctx).await.map(|_| true)
}

pub async fn clean_messages(
    dis: &Dispatch,
    ctx: &Context,
    how_many: ConstrainedU64<1, 100>,
    before: chrono::DateTime<Utc>,
    in_guild: GuildId,
    in_channel: VerifiedChannel,
    for_user: Option<VerifiedUser>,
) -> crate::error::Result<usize> {
    let cv = dis.message_cache().get(&in_guild).ok_or(GuildNotInCache)?;

    let snapshot = cv.snapshot();

    let relevant_messages = snapshot
        .iter()
        .rev()
        .cloned()
        .filter(|m| m.timestamp < before)
        .filter(|m| m.channel == in_channel.into_inner());
    let full_ids: Box<dyn Iterator<Item = MsgInfo> + Send> = if let Some(u) = for_user {
        Box::new(relevant_messages.filter(move |m| m.user == u.into_inner()))
    } else {
        Box::new(relevant_messages)
    };

    let mids = full_ids.take(how_many.to_usize().unwrap()).collect::<Vec<_>>();

    let v = match &mids[..] {
        [] => 0,
        [id] => in_channel.into_inner().delete_message(ctx, id.msg).await.map(|_| 1)?,
        [vals @ ..] => in_channel
            .into_inner()
            .delete_messages(ctx, vals.iter().map(|m| m.msg))
            .await
            .map(|_| mids.len())?,
    };

    cv.remove_all(mids.into_iter());

    Ok(v)
}
